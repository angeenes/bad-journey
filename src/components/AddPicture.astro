---
import Dialog from "./Dialog.astro";
import { API_URL, BEARER_TOKEN } from "../consts";

let endpoint = `${API_URL}tags`;
const headers = {
  "Content-Type": "application/json",
  Authorization: `Bearer ${BEARER_TOKEN}`,
};

const response = await fetch(endpoint, { headers });
const data = await response.json();
const tags = data.data;

---

<!-- <script is:inline src="https://cdn.jsdelivr.net/npm/exifr/dist/full.umd.js"></script> -->
<script is:inline src="/exifr.js"></script>

<Dialog id="success-upload-image">
  <article class="text-center">
    You did it!
    <br>
    <br>
    <button onclick="location.reload(true)">Click here to reload the page and see your uploaded image</button>
  </article>
</Dialog>

<Dialog id="uploadImage" buttonLabel="UPLOAD" title="upload an image" className="bg-pink-500 px-6 py-2 rounded-full uppercase font-bold text-sm">
  <div id="publishing-loading" class="loading">
    <div class="loader"></div>
    <div class="font-black text-pink-500">PUBLISHING IMAGE...</div>
  </div>
  <form id="image-form" class="grid grid-cols-2 gap-16">
    <label
      for="image"
      class="w-full h-full border-custom p-2 pt-14 text-center cursor-s-resize md:min-h-[664px] md:w-[669px]"
    >
      <img
        id="imagePreview"
        src="/img/drop.svg"
        alt="drop an image file"
        class="mx-auto"
      />
      <p class="mt-4">Drag and drop an image, or Browse</p>
      <p class="text-slate-400 text-xs mt-2">Minimum 512px width, max 10MB</p>
      <div class="flex items-center gap-4 mx-auto">
        <input type="number" name="width" id="width"> x <input type="number" name="height" id="height">
      </div>
      <input
        type="file"
        id="image"
        name="image"
        accept="image/png, image/jpeg"
        class="hidden"
      />
    </label>
    <div class="flex flex-col gap-3">
      <label for="prompt"
        >Prompt
        <textarea name="prompt" id="prompt" cols="30" rows="5"></textarea>
      </label>
      <label for="negative_prompt"
        >Negative prompt
        <textarea name="negative_prompt" id="negative_prompt" cols="30" rows="5"
        ></textarea>
      </label>
      <label for="generator"
        >What generator did you use to generate this image?
        <select name="generator" id="generator">
          <option value="midjourney">midjourney</option>
          <option value="Automatic111">Automatic111</option>
          <option value="invoke-ai/InvokeAI">Invoke</option>
          <option value="DiffusionBee">DiffusionBee</option>
          <option value="Mochi">Mochi</option>
          <option value="Other">Other</option>
        </select>
      </label>
      <label for="model">
        What model did you use to generate this image?
        <input type="text" name="model" id="model" />
      </label>
      <label for="seed">
        Seed (optional)
        <input type="number" name="seed" id="seed" />
      </label>
      <label for="cfg_scale">
        Cfg scale (optional)
        <input type="number" name="cfg_scale" id="cfg_scale" step="0.1" min="0" />
      </label>
      <label for="steps">
        Steps (optional)
        <input type="number" name="steps" id="steps" />
      </label>
      <label for="tags">
        category tags
        <select name="tags" id="tags" multiple>
          {tags.map((tag) => (
            <option value={tag.attributes.name}>{tag.attributes.name}</option>
          ))}
        </select>
      </label>
      <button
        disabled
        id="publish-button"
        type="submit"
        class="mt-4 text-white text-center p-3 rounded-3xl text-sm bg-primary font-bold flex items-center justify-center gap-x-2 cursor-not-allowed opacity-5"> <img src="/img/send-airplane.svg" alt="publich now"> PUBLISH NOW</button
      >
    </div>
  </form>
</Dialog>

<style>
  .border-custom {
    background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='16' ry='16' stroke='hotpink' stroke-width='4' stroke-dasharray='6%2c 14' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
    border-radius: 16px;
  }
</style>

<script>
  import { API_URL, BEARER_TOKEN_POST_IMAGES } from "../consts";
  import convertAutomatic111Metadata from "@classes/converters/convertAutomatic111Metadata";
  import convertInvokeMetadata from "@classes/converters/convertInvokeMetadata";
  import convertMochiMetadata from "@classes/converters/convertMochiMetadata";
  import { ImageObject } from "../assets/types/ImageObject.js";

  class ImageMetadataForm {
    constructor(
      private imagePreview: HTMLImageElement = document.getElementById("imagePreview") as HTMLImageElement,
      private imageInput = document.getElementById("image") as HTMLInputElement,
      public formEl: HTMLFormElement = document.getElementById("image-form") as HTMLFormElement,
      private loadingEl: HTMLDivElement = document.getElementById("publishing-loading") as HTMLDivElement,
      private successDialog: HTMLDialogElement = document.getElementById("success-upload-image") as HTMLDialogElement,
      private publishButtonSubmitEl: HTMLButtonElement = document.getElementById("publish-button") as HTMLButtonElement,
    ) {
      this.init();
    }

    private async init(): Promise<void> {
      this.formEl.addEventListener("submit", this.handleSubmit.bind(this));
      this.imageInput.addEventListener("change", this.previewImage.bind(this));
    }

    private previewImage() {

      if (!this.imageInput.files || this.imageInput.files.length === 0) return;

      const imageFile = this.imageInput.files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        if (!e.target) return;

        this.imagePreview.src = e.target.result as string;
        this.updateFormFields(imageFile);
      };
      reader.readAsDataURL(imageFile);
    }

    private async updateFormFields(imageFile: File) {
      let objectImageDatas: ImageObject = {} as ImageObject;
      try {
        const metadata = await exifr.parse(imageFile, {
          tiff: false,
          xmp: true,
        });

        if (metadata) {
          console.log("metadata", metadata);
          if (metadata["sd-metadata"]) {
            console.log("INVOKE");
            const jsObject = JSON.parse(metadata["sd-metadata"]);
            objectImageDatas = convertInvokeMetadata(jsObject);
            console.log("objectImageDatas RETOURNE", objectImageDatas);
            this.fillForm(objectImageDatas);
          }


          if (metadata["description"]) {
            console.log("MOCHI");
            objectImageDatas = convertMochiMetadata(metadata["description"]);
            console.log("objectImageDatas RETOURNE", objectImageDatas);
            this.fillForm(objectImageDatas);
          }


          if (metadata["parameters"]) {
            console.log("AUTOMATIC111");
            const object = metadata["parameters"]
            objectImageDatas = convertAutomatic111Metadata(object);
            console.log("objectImageDatas RETOURNE", objectImageDatas);
            this.fillForm(objectImageDatas);
          }


        }
      } catch (error) {
        console.error("Failed to read metadata:", error);
      }
    }

    private fillForm(data: ImageObject) {

      for (const key in data) {
        const element = this.formEl.querySelector(`[name="${key}"]`) as
          | HTMLInputElement
          | HTMLTextAreaElement
          | HTMLSelectElement
          | null;
        if (element) {
          element.value = data[key];
        }
      }
      this.allowBtnPublish();
    }

    private allowBtnPublish(): void{
      this.publishButtonSubmitEl.classList.remove("opacity-5");
      this.publishButtonSubmitEl.disabled = false;
      this.publishButtonSubmitEl.classList.toggle("cursor-not-allowed");
    }

    private toggleLoadingPublishImage(): void {
      
      this.publishButtonSubmitEl.classList.toggle("opacity-70");
      this.publishButtonSubmitEl.disabled = !this.publishButtonSubmitEl.disabled;
      this.loadingEl.classList.toggle("active");
      // publishButtonSubmitEl.innerHTML="PUBLISHING..."
    }

    private resetForm() {
      this.formEl.reset();
    }

    private async handleSubmit(event: Event) {
      event.preventDefault();
      this.toggleLoadingPublishImage();

      const form = event.target as HTMLFormElement;
      const data = {};
      const formData = new FormData();

      Array.from(form.elements).forEach(({ name, type, value, files }) => {
        if (!["submit", "file"].includes(type)) {
          if(name === 'tags') {
            console.log('tags', type, name, value);
            data[name] = { "name": value};
          } else {
            data[name] = value;
          }
        } else if (type === "file") {
          Array.from(files).forEach((file) => {
            formData.append(`files.${name}`, file, file.name);
          });
        }
      });

      formData.append("data", JSON.stringify(data));

      try {
        const response = await fetch(`${API_URL}images`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${BEARER_TOKEN_POST_IMAGES}`,
          },
          body: formData,
        });

        if (response.ok) {
          console.log("Data submitted successfully");
          this.resetForm();
          closeDialogId("uploadImage");
          this.resetForm();
          this.toggleLoadingPublishImage()
          openDialogId("success-upload-image");
        } else {
          console.error("Failed to submit data:", response.statusText);
        }
      } catch (error) {
        console.error("Failed to submit data:", error);
      }
    }
  }

  const imageMetadataForm = new ImageMetadataForm();
</script>
